<?xml version='1.0' encoding='UTF-8'?>
<SmellBaseline>
  <ManuallySuppressedIssues/>
  <CurrentIssues>
    <ID>ComplexCondition:CollectionExtensions.kt$x &lt; size &amp;&amp; (y == replaceWith.size || (y &lt; replaceWith.size &amp;&amp; !diffCallback.areItemsTheSame(this[x], replaceWith[y])))</ID>
    <ID>ComplexMethod:Updater.kt$fun updateForUiMessage( message: UIMessage, state: State ): UpdateWith&lt;State, Command></ID>
    <ID>ConstructorParameterNaming:Transitions.kt$ChildTransitionState$val _contentAlpha: State&lt;Float></ID>
    <ID>ConstructorParameterNaming:Transitions.kt$ChildTransitionState$val _listItemOffsetY: State&lt;Dp></ID>
    <ID>ConstructorParameterNaming:Transitions.kt$HeaderTransitionState$val _cornerRadius: State&lt;Dp></ID>
    <ID>ConstructorParameterNaming:Transitions.kt$HeaderTransitionState$val _elevation: State&lt;Dp></ID>
    <ID>ConstructorParameterNaming:Transitions.kt$HeaderTransitionState$val _horizontalPadding: State&lt;Dp></ID>
    <ID>ConstructorParameterNaming:Transitions.kt$HeaderTransitionState$val _indicatorColor: State&lt;Color></ID>
    <ID>ConstructorParameterNaming:Transitions.kt$HeaderTransitionState$val _textBackground: State&lt;Color></ID>
    <ID>FunctionOnlyReturningConstant:RenderExtensions.kt$@Suppress("unused") internal fun Null.toReadableString(): String</ID>
    <ID>LongParameterList:Component.kt$( id: ComponentId, noinline initializer: Initializer&lt;S, C>, noinline resolver: Resolver&lt;C, M>, noinline updater: Updater&lt;M, S, C>, scope: CoroutineScope, // todo: group to reduce number of arguments url: Url = Localhost, jsonSerializer: JsonSerializer&lt;J>, // see https://youtrack.jetbrains.com/issue/KT-47195 // see https://github.com/Kotlin/kotlinx.coroutines/issues/3005#issuecomment-1014577573 noinline sessionFactory: SessionFactory&lt;M, S, J> = { settings, block -> HttpClient.session(settings, block) }, shareOptions: ShareOptions = ShareStateWhileSubscribed, )</ID>
    <ID>LongParameterList:SettingsScreen.kt$( icon: ImageVector, imageDescription: String?, title: String, description: String, checked: Boolean, enabled: Boolean = true, onCheckedChange: (Boolean) -> Unit, )</ID>
    <ID>LongParameterList:SourcesSection.kt$( state: FiltersState, id: ScreenId, modifier: Modifier, sources: Loadable&lt;Source>, childTransitionState: ChildTransitionState, handler: MessageHandler, )</ID>
    <ID>LongParameterList:TreeView.kt$( level: Int, text: String, formatter: TreeFormatter, node: SnapshotINode, state: TreeState, handler: MessageHandler )</ID>
    <ID>LongParameterList:TreeView.kt$( level: Int, text: String, node: RefNode, formatter: TreeFormatter, state: TreeState, handler: MessageHandler, )</ID>
    <ID>LongParameterList:TreeView.kt$( level: Int, text: String, painter: Painter, leaf: Node, state: TreeState, handler: MessageHandler, )</ID>
    <ID>LongParameterList:TreeView.kt$( level: Int, text: String, painter: Painter, node: INode, state: TreeState, handler: MessageHandler )</ID>
    <ID>LongParameterList:TreeView.kt$( node: CollectionNode, level: Int, text: String, formatter: TreeFormatter, state: TreeState, handler: MessageHandler )</ID>
    <ID>LongParameterList:TreeView.kt$( node: Node, level: Int, formatter: TreeFormatter, text: String, state: TreeState, handler: MessageHandler )</ID>
    <ID>MagicNumber:Balloon.kt$15</ID>
    <ID>MagicNumber:Balloon.kt$15_000L</ID>
    <ID>MagicNumber:Balloon.kt$30</ID>
    <ID>MagicNumber:Colors.kt$0x33412E</ID>
    <ID>MagicNumber:Colors.kt$0x704745</ID>
    <ID>MagicNumber:Colors.kt$0xFFD00036</ID>
    <ID>MagicNumber:Colors.kt$0xFFF70040</ID>
    <ID>MagicNumber:Colors.kt$0xFFFFFFFF</ID>
    <ID>MagicNumber:Colors.kt$0xbaeeba</ID>
    <ID>MagicNumber:Colors.kt$0xffbd2b52</ID>
    <ID>MagicNumber:Colors.kt$0xffcccc</ID>
    <ID>MagicNumber:Colors.kt$0xffdb2a59</ID>
    <ID>MagicNumber:Colors.kt$18</ID>
    <ID>MagicNumber:Colors.kt$182</ID>
    <ID>MagicNumber:Colors.kt$242</ID>
    <ID>MagicNumber:Colors.kt$4</ID>
    <ID>MagicNumber:Colors.kt$6</ID>
    <ID>MagicNumber:ComponentTest.kt$ComponentTest$1_000</ID>
    <ID>MagicNumber:ComponentTest.kt$ComponentTest$3</ID>
    <ID>MagicNumber:Date.kt$1000.0</ID>
    <ID>MagicNumber:InsetAwareTopAppBar.kt$100</ID>
    <ID>MagicNumber:InsetAwareTopAppBar.kt$100f</ID>
    <ID>MagicNumber:LocalStorageImpl.kt$3</ID>
    <ID>MagicNumber:LocalStorageImpl.kt$4</ID>
    <ID>MagicNumber:LocalStorageImpl.kt$5</ID>
    <ID>MagicNumber:LocalStorageImpl.kt$7</ID>
    <ID>MagicNumber:LocalStorageImpl.kt$8</ID>
    <ID>MagicNumber:NettyServer.kt$10</ID>
    <ID>MagicNumber:NettyServer.kt$5</ID>
    <ID>MagicNumber:Plugin.kt$86</ID>
    <ID>MagicNumber:TempTest.kt$TempTest$1_000</ID>
    <ID>MagicNumber:TempTest.kt$TempTest$3</ID>
    <ID>MagicNumber:WidgetTheme.kt$109</ID>
    <ID>MagicNumber:WidgetTheme.kt$148</ID>
    <ID>MagicNumber:WidgetTheme.kt$70</ID>
    <ID>MaxLineLength:AppTheme.kt$val secondaryVariant by animateColorAsState(if (!isDarkModeEnabled) LightThemeColors.secondaryVariant else DarkThemeColors.secondaryVariant)</ID>
    <ID>MaxLineLength:CollectionExtensionsTest.kt$CollectionExtensionsTest$val input = mutableListOf(263, 110, 109, 156, 158, 161, 166, 170, 176, 186, 150, 189, 194, 197, 199, 204, 176, 186, 150, 189, 194, 197, 199, 204)</ID>
    <ID>MaxLineLength:FiltersTest.kt$FiltersTest$fun</ID>
    <ID>NewLineAtEndOfFile:Adapters.kt$com.oliynick.max.reader.app.serialization.Adapters.kt</ID>
    <ID>NewLineAtEndOfFile:AndroidAppComponent.kt$com.max.reader.app.AndroidAppComponent.kt</ID>
    <ID>NewLineAtEndOfFile:Annotations.kt$com.oliynick.max.reader.app.Annotations.kt</ID>
    <ID>NewLineAtEndOfFile:ArticleDetailsModule.kt$com.oliynick.max.reader.app.feature.article.details.ArticleDetailsModule.kt</ID>
    <ID>NewLineAtEndOfFile:ComponentException.kt$com.oliynick.max.tea.core.misc.ComponentException.kt</ID>
    <ID>NewLineAtEndOfFile:ComponentTest.kt$com.oliynick.max.tea.core.component.ComponentTest.kt</ID>
    <ID>NewLineAtEndOfFile:ComposeAnnotations.kt$com.oliynick.max.reader.app.ComposeAnnotations.kt</ID>
    <ID>NewLineAtEndOfFile:CompositionsLogger.kt$com.max.reader.app.ui.misc.CompositionsLogger.kt</ID>
    <ID>NewLineAtEndOfFile:Date.kt$io.github.xlopec.tea.data.Date.kt</ID>
    <ID>NewLineAtEndOfFile:DebuggableComponentTest.kt$com.oliynick.max.tea.core.debug.component.DebuggableComponentTest.kt</ID>
    <ID>NewLineAtEndOfFile:Either.kt$io.github.xlopec.tea.data.Either.kt</ID>
    <ID>NewLineAtEndOfFile:Environment.kt$com.oliynick.max.reader.app.Environment.kt</ID>
    <ID>NewLineAtEndOfFile:ExportImportTest.kt$com.oliynick.max.tea.core.debug.app.feature.storage.ExportImportTest.kt</ID>
    <ID>NewLineAtEndOfFile:IosAnnotations.kt$com.oliynick.max.reader.app.IosAnnotations.kt</ID>
    <ID>NewLineAtEndOfFile:LiveArticleDetailsResolver.kt$com.oliynick.max.reader.app.feature.article.details.LiveArticleDetailsResolver.kt</ID>
    <ID>NewLineAtEndOfFile:LocalStorage.kt$com.oliynick.max.reader.app.feature.storage.LocalStorage.kt</ID>
    <ID>NewLineAtEndOfFile:LocalStorageImpl.kt$com.oliynick.max.reader.app.feature.storage.LocalStorageImpl.kt</ID>
    <ID>NewLineAtEndOfFile:MockResponses.kt$com.max.reader.environment.MockResponses.kt</ID>
    <ID>NewLineAtEndOfFile:NavigationExtensionsTest.kt$com.oliynick.max.reader.app.NavigationExtensionsTest.kt</ID>
    <ID>NewLineAtEndOfFile:NewsApi.kt$com.oliynick.max.reader.app.feature.article.list.NewsApi.kt</ID>
    <ID>NewLineAtEndOfFile:PluginDependenciesSpecExt.kt$.PluginDependenciesSpecExt.kt</ID>
    <ID>NewLineAtEndOfFile:PopScreen.kt$com.oliynick.max.reader.app.feature.navigation.PopScreen.kt</ID>
    <ID>NewLineAtEndOfFile:Screens.kt$com.oliynick.max.reader.app.Screens.kt</ID>
    <ID>NewLineAtEndOfFile:Thread.kt$com.oliynick.max.tea.core.misc.Thread.kt</ID>
    <ID>NewLineAtEndOfFile:UUID.kt$io.github.xlopec.tea.data.UUID.kt</ID>
    <ID>NewLineAtEndOfFile:Url.kt$io.github.xlopec.tea.data.Url.kt</ID>
    <ID>NewLineAtEndOfFile:build.gradle.kts$.build.gradle.kts</ID>
    <ID>NewLineAtEndOfFile:currentThreadName.kt$com.oliynick.max.tea.core.misc.currentThreadName.kt</ID>
    <ID>NewLineAtEndOfFile:multiplatform-library.gradle.kts$.multiplatform-library.gradle.kts</ID>
    <ID>NewLineAtEndOfFile:publish-convention.gradle.kts$.publish-convention.gradle.kts</ID>
    <ID>NewLineAtEndOfFile:published-multiplatform-library.gradle.kts$.published-multiplatform-library.gradle.kts</ID>
    <ID>NewLineAtEndOfFile:settings.gradle.kts$.settings.gradle.kts</ID>
    <ID>NewLineAtEndOfFile:toJson.kt$com.oliynick.max.reader.app.feature.network.toJson.kt</ID>
    <ID>TooGenericExceptionCaught:NettyServer.kt$e: Throwable</ID>
    <ID>TooGenericExceptionCaught:NewsApiImpl.kt$NewsApiImpl$th: Throwable</ID>
    <ID>TooManyFunctions:ComponentTest.kt$ComponentTest</ID>
    <ID>TooManyFunctions:RenderExtensions.kt$com.oliynick.max.tea.core.debug.app.feature.presentation.ui.components.misc.RenderExtensions.kt</ID>
    <ID>TooManyFunctions:TempTest.kt$TempTest</ID>
    <ID>UndocumentedPublicClass:ComponentException.kt$ComponentException : IllegalStateException</ID>
    <ID>UndocumentedPublicClass:ComponentLogic.kt$AddItem : Message</ID>
    <ID>UndocumentedPublicClass:ComponentLogic.kt$Command</ID>
    <ID>UndocumentedPublicClass:ComponentLogic.kt$DoAddItem : Command</ID>
    <ID>UndocumentedPublicClass:ComponentLogic.kt$DoRemoveItem : Command</ID>
    <ID>UndocumentedPublicClass:ComponentLogic.kt$Item</ID>
    <ID>UndocumentedPublicClass:ComponentLogic.kt$Message</ID>
    <ID>UndocumentedPublicClass:ComponentLogic.kt$RemoveItem : Message</ID>
    <ID>UndocumentedPublicClass:ComponentLogic.kt$TodoState</ID>
    <ID>UndocumentedPublicClass:ComponentLogic.kt$Updated : Message</ID>
    <ID>UndocumentedPublicClass:ComponentTest.kt$ComponentTest</ID>
    <ID>UndocumentedPublicClass:ComponentTest.kt$ForeverWaitingResolver&lt;T></ID>
    <ID>UndocumentedPublicClass:Date.kt$Date</ID>
    <ID>UndocumentedPublicClass:Either.kt$Either&lt;out L, out R></ID>
    <ID>UndocumentedPublicClass:Either.kt$Left&lt;L> : Either</ID>
    <ID>UndocumentedPublicClass:Either.kt$Right&lt;R> : Either</ID>
    <ID>UndocumentedPublicClass:TempTest.kt$ForeverWaitingResolver&lt;T></ID>
    <ID>UndocumentedPublicClass:TempTest.kt$TempTest</ID>
    <ID>UndocumentedPublicClass:UUID.kt$UUID</ID>
    <ID>UndocumentedPublicClass:Url.kt$Url</ID>
    <ID>UndocumentedPublicFunction:Component.kt$@Suppress("RedundantSuspendModifier") suspend fun &lt;C> throwingResolver( c: C, ): Nothing</ID>
    <ID>UndocumentedPublicFunction:Component.kt$fun &lt;M, S, C> CoroutineScope.TestEnv( initializer: Initializer&lt;S, C>, resolver: Resolver&lt;C, M>, updater: Updater&lt;M, S, C>, shareOptions: ShareOptions = ShareStateWhileSubscribed, )</ID>
    <ID>UndocumentedPublicFunction:Component.kt$fun &lt;M, S> ignoringMessageAsStateUpdate( message: M, @Suppress("UNUSED_PARAMETER") state: S, ): UpdateWith&lt;M, S></ID>
    <ID>UndocumentedPublicFunction:Component.kt$fun &lt;M, S> messageAsCommand( message: M, @Suppress("UNUSED_PARAMETER") state: S, ): UpdateWith&lt;S, M></ID>
    <ID>UndocumentedPublicFunction:Component.kt$fun &lt;M, S> throwingUpdater( m: M, s: S, ): Nothing</ID>
    <ID>UndocumentedPublicFunction:Component.kt$fun &lt;S> messageAsStateUpdate( message: S, @Suppress("UNUSED_PARAMETER") state: S, ): UpdateWith&lt;S, S></ID>
    <ID>UndocumentedPublicFunction:ComponentLogic.kt$fun testUpdate(message: Message, state: TodoState): UpdateWith&lt;TodoState, Command></ID>
    <ID>UndocumentedPublicFunction:ComponentLogic.kt$suspend fun testResolver(cmd: Command): Set&lt;Message></ID>
    <ID>UndocumentedPublicFunction:ComponentTest.kt$ComponentTest$@Test fun `when attaching interceptor to component then original sequence of snapshots pipes through it`()</ID>
    <ID>UndocumentedPublicFunction:ComponentTest.kt$ComponentTest$@Test fun `when collecting component given initializer throws exception then it's handled by coroutine scope`()</ID>
    <ID>UndocumentedPublicFunction:ComponentTest.kt$ComponentTest$@Test fun `when collecting component given updater throws exception then it's handled by coroutine scope`()</ID>
    <ID>UndocumentedPublicFunction:ComponentTest.kt$ComponentTest$@Test fun `when collecting component with specific dispatcher then updater runs on this dispatcher`()</ID>
    <ID>UndocumentedPublicFunction:ComponentTest.kt$ComponentTest$@Test fun `when component has multiple consumers then component is initialized only once`()</ID>
    <ID>UndocumentedPublicFunction:ComponentTest.kt$ComponentTest$@Test fun `when component has multiple consumers then it can serve multiple message sources`()</ID>
    <ID>UndocumentedPublicFunction:ComponentTest.kt$ComponentTest$@Test fun `when component has multiple consumers then snapshots are shared among them`()</ID>
    <ID>UndocumentedPublicFunction:ComponentTest.kt$ComponentTest$@Test fun `when component receives input given recursive calculations then it emits correct sequence of snapshots`()</ID>
    <ID>UndocumentedPublicFunction:ComponentTest.kt$ComponentTest$@Test fun `when component receives input then it emits correct sequence of snapshots`()</ID>
    <ID>UndocumentedPublicFunction:ComponentTest.kt$ComponentTest$@Test fun `when subscriber disconnects then component initializer is re-invoked`()</ID>
    <ID>UndocumentedPublicFunction:ComponentTest.kt$ComponentTest$@Test fun `when upstream receives new input then previous downstream is canceled`()</ID>
    <ID>UndocumentedPublicFunction:ComponentTest.kt$ForeverWaitingResolver$suspend fun resolveForever( t: T, ): Nothing</ID>
    <ID>UndocumentedPublicFunction:ComponentTest.kt$fun ThrowingInitializer( th: Throwable, ): Initializer&lt;Nothing, Nothing></ID>
    <ID>UndocumentedPublicFunction:Date.kt$public actual fun Date.toMillis(): Long</ID>
    <ID>UndocumentedPublicFunction:Date.kt$public actual fun fromMillis( millis: Long ): Date</ID>
    <ID>UndocumentedPublicFunction:Date.kt$public actual fun now(): Date</ID>
    <ID>UndocumentedPublicFunction:Date.kt$public expect fun Date.toMillis(): Long</ID>
    <ID>UndocumentedPublicFunction:Date.kt$public expect fun fromMillis( millis: Long ): Date</ID>
    <ID>UndocumentedPublicFunction:Date.kt$public expect fun now(): Date</ID>
    <ID>UndocumentedPublicFunction:Either.kt$//@OptIn(ExperimentalContracts::class) public operator fun &lt;L> Either&lt;L, *>.component1(): L?</ID>
    <ID>UndocumentedPublicFunction:Either.kt$//@OptIn(ExperimentalContracts::class) public operator fun &lt;R> Either&lt;*, R>.component2(): R?</ID>
    <ID>UndocumentedPublicFunction:Either.kt$@JvmName("LeftUnit") public inline fun Left( ifSuccess: () -> Unit, ): Left&lt;Nothing?></ID>
    <ID>UndocumentedPublicFunction:Either.kt$public inline fun &lt;L, R, T, F> Either&lt;L, R>.bimap( left: (L) -> T, right: (R) -> F ): Either&lt;T, F></ID>
    <ID>UndocumentedPublicFunction:Either.kt$public inline fun &lt;L, R, T> Either&lt;L, R>.fold( left: (L) -> T, right: (R) -> T ): T</ID>
    <ID>UndocumentedPublicFunction:Either.kt$public inline fun &lt;L, R, T> Either&lt;L, R>.mapL( left: (L) -> T, ): Either&lt;T, R></ID>
    <ID>UndocumentedPublicFunction:Either.kt$public inline fun &lt;L, R, T> Either&lt;L, R>.mapR( right: (R) -> T ): Either&lt;L, T></ID>
    <ID>UndocumentedPublicFunction:Either.kt$public inline fun &lt;L, R> Either( ifSuccess: () -> L, ifFailure: (th: Throwable) -> R ): Either&lt;L, R></ID>
    <ID>UndocumentedPublicFunction:Either.kt$public inline fun &lt;L> Either( ifSuccess: () -> L, ): Either&lt;L, Throwable></ID>
    <ID>UndocumentedPublicFunction:Either.kt$public inline fun &lt;L> Left( ifSuccess: () -> L, ): Left&lt;L></ID>
    <ID>UndocumentedPublicFunction:FlowExtensions.kt$@Deprecated("Bad api") @InternalTeaApi public suspend fun &lt;T> Flow&lt;T>.into( sendChannel: SendChannel&lt;T> )</ID>
    <ID>UndocumentedPublicFunction:TempTest.kt$ForeverWaitingResolver$suspend fun resolveForever( t: T, ): Nothing</ID>
    <ID>UndocumentedPublicFunction:TempTest.kt$TempTest$@Test fun `when attaching interceptor to component, then original sequence of snapshots pipes through it`()</ID>
    <ID>UndocumentedPublicFunction:TempTest.kt$TempTest$@Test fun `when collecting component, given initializer throws exception, then it's handled by coroutine scope`()</ID>
    <ID>UndocumentedPublicFunction:TempTest.kt$TempTest$@Test fun `when collecting component, given updater throws exception, then it's handled by coroutine scope`()</ID>
    <ID>UndocumentedPublicFunction:TempTest.kt$TempTest$@Test fun `when component has multiple consumers, then component is initialized only once`()</ID>
    <ID>UndocumentedPublicFunction:TempTest.kt$TempTest$@Test fun `when component has multiple consumers, then it can serve multiple message sources`()</ID>
    <ID>UndocumentedPublicFunction:TempTest.kt$TempTest$@Test fun `when component has multiple consumers, then snapshots are shared among them`()</ID>
    <ID>UndocumentedPublicFunction:TempTest.kt$TempTest$@Test fun `when component receives input, given recursive calculations, then it emits correct sequence of snapshots`()</ID>
    <ID>UndocumentedPublicFunction:TempTest.kt$TempTest$@Test fun `when component receives input, then it emits correct sequence of snapshots`()</ID>
    <ID>UndocumentedPublicFunction:TempTest.kt$TempTest$@Test fun `when subscriber disconnects, then component initializer is re-invoked`()</ID>
    <ID>UndocumentedPublicFunction:TempTest.kt$TempTest$@Test fun `when upstream receives new input, then previous downstream is canceled`()</ID>
    <ID>UndocumentedPublicFunction:TempTest.kt$fun ThrowingInitializer( th: Throwable, ): Initializer&lt;Nothing, Nothing></ID>
    <ID>UndocumentedPublicFunction:TestEnv.kt$@Suppress("RedundantSuspendModifier") suspend fun &lt;C> throwingResolver( c: C, ): Nothing</ID>
    <ID>UndocumentedPublicFunction:TestEnv.kt$fun &lt;M, S, C> TestDebugEnv( env: Env&lt;M, S, C>, settings: Settings&lt;M, S, JsonElement> = TestSettings() )</ID>
    <ID>UndocumentedPublicFunction:TestEnv.kt$fun &lt;M, S, C> TestScope.TestEnv( initializer: Initializer&lt;S, C>, resolver: Resolver&lt;C, M>, updater: Updater&lt;M, S, C>, shareOptions: ShareOptions = ShareStateWhileSubscribed, )</ID>
    <ID>UndocumentedPublicFunction:TestEnv.kt$fun &lt;M, S> TestSettings( componentId: ComponentId = TestComponentId, converter: JsonSerializer&lt;JsonElement> = GsonSerializer(), url: Url = Localhost, sessionFactory: SessionFactory&lt;M, S, JsonElement> = { _, block -> TestDebugSession&lt;M, S>().apply { block() } } )</ID>
    <ID>UndocumentedPublicFunction:TestEnv.kt$fun &lt;M, S> ignoringMessageAsStateUpdate( message: M, @Suppress("UNUSED_PARAMETER") state: S, ): UpdateWith&lt;M, S></ID>
    <ID>UndocumentedPublicFunction:TestEnv.kt$fun &lt;M, S> messageAsCommand( message: M, @Suppress("UNUSED_PARAMETER") state: S, ): UpdateWith&lt;S, M></ID>
    <ID>UndocumentedPublicFunction:TestEnv.kt$fun &lt;M, S> throwingUpdater( m: M, s: S, ): Nothing</ID>
    <ID>UndocumentedPublicFunction:TestEnv.kt$fun &lt;S> messageAsStateUpdate( message: S, @Suppress("UNUSED_PARAMETER") state: S, ): UpdateWith&lt;S, S></ID>
    <ID>UndocumentedPublicFunction:UUID.kt$public actual fun RandomUUID(): UUID</ID>
    <ID>UndocumentedPublicFunction:UUID.kt$public actual fun UUID.toHumanReadable(): String</ID>
    <ID>UndocumentedPublicFunction:UUID.kt$public actual fun UUIDFrom( value: String ): UUID</ID>
    <ID>UndocumentedPublicFunction:UUID.kt$public actual fun UUIDFrom( value: String, ): UUID</ID>
    <ID>UndocumentedPublicFunction:UUID.kt$public expect fun RandomUUID(): UUID</ID>
    <ID>UndocumentedPublicFunction:UUID.kt$public expect fun UUID.toHumanReadable(): String</ID>
    <ID>UndocumentedPublicFunction:UUID.kt$public expect fun UUIDFrom( value: String ): UUID</ID>
    <ID>UndocumentedPublicFunction:Url.kt$public actual fun Url.toExternalValue(): String</ID>
    <ID>UndocumentedPublicFunction:Url.kt$public actual fun UrlFor( s: String ): Url</ID>
    <ID>UndocumentedPublicFunction:Url.kt$public expect fun Url.toExternalValue(): String</ID>
    <ID>UndocumentedPublicFunction:Url.kt$public expect fun UrlFor( s: String ): Url</ID>
    <ID>UndocumentedPublicProperty:ComponentLogic.kt$AddItem$val item: Item</ID>
    <ID>UndocumentedPublicProperty:ComponentLogic.kt$DoAddItem$val item: Item</ID>
    <ID>UndocumentedPublicProperty:ComponentLogic.kt$DoAddItem$val to: List&lt;Item> = emptyList()</ID>
    <ID>UndocumentedPublicProperty:ComponentLogic.kt$DoRemoveItem$val from: List&lt;Item> = emptyList()</ID>
    <ID>UndocumentedPublicProperty:ComponentLogic.kt$DoRemoveItem$val item: Item</ID>
    <ID>UndocumentedPublicProperty:ComponentLogic.kt$Item$val what: String</ID>
    <ID>UndocumentedPublicProperty:ComponentLogic.kt$RemoveItem$val item: Item</ID>
    <ID>UndocumentedPublicProperty:ComponentLogic.kt$TodoState$val items: List&lt;Item> = emptyList()</ID>
    <ID>UndocumentedPublicProperty:ComponentLogic.kt$Updated$val items: List&lt;Item></ID>
    <ID>UndocumentedPublicProperty:ComponentTest.kt$ForeverWaitingResolver$val messages: ReceiveChannel&lt;T> = _messages</ID>
    <ID>UndocumentedPublicProperty:ComponentTest.kt$const val TestTimeoutMillis = 10 * 1000L</ID>
    <ID>UndocumentedPublicProperty:ComponentTest.kt$inline val CoroutineScope.job: Job get() = coroutineContext[Job.Key] ?: error("scope doesn't have job $this")</ID>
    <ID>UndocumentedPublicProperty:Either.kt$Left$val value: L</ID>
    <ID>UndocumentedPublicProperty:Either.kt$Right$val value: R</ID>
    <ID>UndocumentedPublicProperty:Environment.kt$@ExperimentalTeaApi public val ShareStateWhileSubscribed: ShareOptions = ShareOptions(SharingStarted.WhileSubscribed(), 1U)</ID>
    <ID>UndocumentedPublicProperty:TempTest.kt$ForeverWaitingResolver$val messages: ReceiveChannel&lt;T> = _messages</ID>
    <ID>UndocumentedPublicProperty:TempTest.kt$const val TestTimeoutMillis = 10 * 1000L</ID>
    <ID>UndocumentedPublicProperty:TempTest.kt$inline val CoroutineScope.job: Job get() = coroutineContext[Job.Key] ?: error("scope doesn't have job $this")</ID>
    <ID>UndocumentedPublicProperty:TestEnv.kt$@OptIn(ExperimentalStdlibApi::class) val TestScope.coroutineDispatcher: CoroutineDispatcher get() = coroutineContext[CoroutineDispatcher.Key]!!</ID>
    <ID>UndocumentedPublicProperty:TestEnv.kt$val TestComponentId = ComponentId("test")</ID>
    <ID>UndocumentedPublicProperty:TestEnv.kt$val TestSerializer = GsonSerializer()</ID>
    <ID>UndocumentedPublicProperty:Url.kt$public actual val Url.domain: String get() = host</ID>
    <ID>UndocumentedPublicProperty:Url.kt$public actual val Url.domain: String get() = host ?: error("No domain: ${toExternalValue()}")</ID>
    <ID>UndocumentedPublicProperty:Url.kt$public expect val Url.domain: String</ID>
  </CurrentIssues>
</SmellBaseline>
